<!doctype html><html lang=vi><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=generator content="Hugo 0.26 with theme Tranquilpeak 0.4.1-BETA"><title>[JS] Async Await cực đơn giản</title><meta name=author content="Do Minh Hai"><meta name=keywords content="JavaScript,JS,ES2017,ES6,dominhhai,programming,computer science,machine learning,deep learning"><link rel=icon href=https://dominhhai.github.io/favicon/golden-buddha-512-79567.png><link rel=canonical href=https://dominhhai.github.io/vi/2016/10/js-async-await-is-simple/><meta name=description content="Với các đặc tả JavaScript cũ, ta phải sử dụng các hàm phản hồi để xử lý các thao tác bất đồng bộ. Tuy nhiên việc này dẫn tới tình trạng callback hell khi ta có nhiều thao tác bất đồng bộ phải chờ nhau thực hiện. Call hell làm cho mã nguồn của ta rất rối và khó bảo trì."><meta property=og:type content=website><meta property=og:title content="[JS] Async Await cực đơn giản"><meta property=og:url content=https://dominhhai.github.io/vi/2016/10/js-async-await-is-simple/><meta property=og:description content="Với các đặc tả JavaScript cũ, ta phải sử dụng các hàm phản hồi để xử lý các thao tác bất đồng bộ. Tuy nhiên việc này dẫn tới tình trạng callback hell khi ta có nhiều thao tác bất đồng bộ phải chờ nhau thực hiện. Call hell làm cho mã nguồn của ta rất rối và khó bảo trì."><meta property=og:site_name content="Hai's Blog"><meta property=og:locale content=vi><meta name=twitter:card content=summary><meta name=twitter:title content="[JS] Async Await cực đơn giản"><meta name=twitter:url content=https://dominhhai.github.io/vi/2016/10/js-async-await-is-simple/><meta name=twitter:description content="Với các đặc tả JavaScript cũ, ta phải sử dụng các hàm phản hồi để xử lý các thao tác bất đồng bộ. Tuy nhiên việc này dẫn tới tình trạng callback hell khi ta có nhiều thao tác bất đồng bộ phải chờ nhau thực hiện. Call hell làm cho mã nguồn của ta rất rối và khó bảo trì."><meta name=twitter:creator content=@minhhai3b><meta property=og:image content="https://www.gravatar.com/avatar/711b36be8e444cd1d60b348077bfd752?s=640"><meta name=twitter:image content="https://www.gravatar.com/avatar/711b36be8e444cd1d60b348077bfd752?s=640"><meta property=og:image content=https://res.cloudinary.com/dominhhai/image/upload/code/js.svg><meta name=twitter:image content=https://res.cloudinary.com/dominhhai/image/upload/code/js.svg><link rel=publisher href=https://plus.google.com/115106277658014197977><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css integrity="sha256-eZrrJcwDc/3uDhsdt61sL2oOBY362qM3lon1gyExkL0=" crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/jquery.fancybox.min.css integrity="sha256-vuXZ9LGmmwtjqFX1F+EKin1ThZMub58gKULUyf0qECk=" crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/helpers/jquery.fancybox-thumbs.min.css integrity="sha256-SEa4XYAHihTcEP1f5gARTB2K26Uk8PsndQYHQC1f4jU=" crossorigin=anonymous><link rel=stylesheet href=https://dominhhai.github.io/css/style-fpbzgxsy0kgmdvyrj5ykkg6ratccrk3gocmaqn4xpcjywmv5dteilzucro4f.min.css><link rel=stylesheet crossorigin=anonymous href=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0-alpha1/katex.min.css integrity=sha384-8QOKbPtTFvh/lMY0qPVbXj9hDh+v8US0pD//FcoYFst2lCIf0BmT58+Heqj0IGyx><link rel=stylesheet href=https://dominhhai.github.io/css/main.css><script async src="https://www.googletagmanager.com/gtag/js?id=UA-105333519-1"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)};gtag('js',new Date());gtag('config','UA-105333519-1');</script></head><body><div id=blog><header id=header data-behavior=5><i id=btn-open-sidebar class="fa fa-lg fa-bars"></i><div class=header-title><a class=header-title-link href=https://dominhhai.github.io/vi/>Hai&#39;s Blog</a></div><a class=header-right-picture href=https://dominhhai.github.io/#about><img class=header-picture src="https://www.gravatar.com/avatar/711b36be8e444cd1d60b348077bfd752?s=90" alt="Ảnh đại diện"></a></header><nav id=sidebar data-behavior=5><div class=sidebar-container><div class=sidebar-profile><a href=https://dominhhai.github.io/#about><img class=sidebar-profile-picture src="https://www.gravatar.com/avatar/711b36be8e444cd1d60b348077bfd752?s=110" alt="Ảnh đại diện"></a><h4 class=sidebar-profile-name>Do Minh Hai</h4><h5 class=sidebar-profile-bio>Just a developer<br>Enjoy life as a journey</h5></div><ul class=sidebar-buttons><li class=sidebar-button><a class=sidebar-button-link href=https://dominhhai.github.io/vi/><i class="sidebar-button-icon fa fa-lg fa-home"></i><span class=sidebar-button-desc>Trang chủ</span></a></li><li class=sidebar-button><a class=sidebar-button-link href=https://dominhhai.github.io/vi/categories/><i class="sidebar-button-icon fa fa-lg fa-bookmark"></i><span class=sidebar-button-desc>Danh mục</span></a></li><li class=sidebar-button><a class=sidebar-button-link href=https://dominhhai.github.io/vi/tags/><i class="sidebar-button-icon fa fa-lg fa-tags"></i><span class=sidebar-button-desc>Thẻ thông tin</span></a></li><li class=sidebar-button><a class=sidebar-button-link href=https://dominhhai.github.io/vi/archives/><i class="sidebar-button-icon fa fa-lg fa-archive"></i><span class=sidebar-button-desc>Lưu trữ</span></a></li><li class=sidebar-button><a class=sidebar-button-link href=https://dominhhai.github.io/vi/#about><i class="sidebar-button-icon fa fa-lg fa-address-card"></i><span class=sidebar-button-desc>Thông tin</span></a></li><li class=sidebar-button><a class=sidebar-button-link href=https://dominhhai.github.io/vi/page/why/><i class="sidebar-button-icon fa fa-lg fa-question"></i><span class=sidebar-button-desc>Hỏi ngu</span></a></li></ul><ul class=sidebar-buttons><li class=sidebar-button><a class=sidebar-button-link href=https://github.com/dominhhai target=_blank rel=noopener><i class="sidebar-button-icon fa fa-lg fa-github"></i><span class=sidebar-button-desc>GitHub</span></a></li><li class=sidebar-button><a class=sidebar-button-link href=https://twitter.com/minhhai3b target=_blank rel=noopener><i class="sidebar-button-icon fa fa-lg fa-twitter"></i><span class=sidebar-button-desc>Twitter</span></a></li></ul><ul class=sidebar-buttons><li class=sidebar-button><a class=sidebar-button-link href=https://dominhhai.github.io/vi/index.xml><i class="sidebar-button-icon fa fa-lg fa-rss"></i><span class=sidebar-button-desc>RSS</span></a></li></ul></div></nav><div id=main data-behavior=5 class=hasCoverMetaIn><article class=post itemscope itemtype=http://schema.org/BlogPosting><div class="post-header main-content-wrap text-center"><h1 class=post-title itemprop=headline>[JS] Async Await cực đơn giản</h1><div class="postShorten-meta post-meta"><time itemprop=datePublished datetime=2016-10-31T00:00:00Z>31 tháng 10, 2016</time>
<span>mục</span>
<a class=category-link href=https://dominhhai.github.io/vi/categories/l%e1%ba%adp-tr%c3%acnh>Lập Trình</a>,
<a class=category-link href=https://dominhhai.github.io/vi/categories/js>JS</a></div></div><div class="post-content markdown" itemprop=articleBody><div class=main-content-wrap><p>Với các đặc tả JavaScript cũ, ta phải sử dụng các hàm phản hồi để xử lý các thao tác bất đồng bộ. Tuy nhiên việc này dẫn tới tình trạng <a href=https://stackoverflow.com/questions/25098066/what-is-callback-hell-and-how-and-why-rx-solves-it>callback hell</a> khi ta có nhiều thao tác bất đồng bộ phải chờ nhau thực hiện. Call hell làm cho mã nguồn của ta rất rối và khó bảo trì.<h1 id=table-of-contents>Mục lục</h1><nav id=TableOfContents><ul><li><a href=#1-giới-thiệu>1. Giới thiệu</a></li><li><a href=#2-cách-sử-dụng>2. Cách sử dụng</a></li><li><a href=#3-lưu-ý>3. Lưu ý</a><ul><li><a href=#3-1-quên-khai-báo-từ-khóa-async>3.1. Quên khai báo từ khóa <code>async</code></a></li><li><a href=#3-2-nhập-nhằng-từ-khóa-await>3.2. Nhập nhằng từ khóa <code>await</code></a></li><li><a href=#3-3-quên-xử-lý-lỗi>3.3. Quên xử lý lỗi</a></li><li><a href=#3-4-mất-tính-song-song>3.4. Mất tính song song</a></li></ul></li><li><a href=#4-nền-tảng-trình-duyệt-hỗ-trợ>4. Nền tảng/ trình duyệt hỗ trợ</a></li><li><a href=#5-kết-luận>5. Kết luận</a></li></ul></nav></p><h1 id=1-giới-thiệu>1. Giới thiệu</h1><p>HUGOMORE42</p><figure class="highlight js"><figcaption><span>test1.js</span></figcaption><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br></pre></td><td class=code><pre class="js code-highlight">function wait(ms, cb) {
  setTimeout(cb, ms)
}

function main() {
  console.log(&#39;sắp rồi...&#39;)
  wait(2007, () =&gt; {
    console.log(&#39;chờ tí...&#39;)
    wait(2012, () =&gt; {
      console.log(&#39;thêm chút nữa thôi...&#39;)
      wait(2016, () =&gt; {
        console.log(&#39;xong rồi đấy!&#39;)
      })
    })
  })
}</pre></td></tr></tbody></table></figure><p>Vì vậy, với phiên bản ES6 (ES 2016), <a href=https://developer.mozilla.org/vi/docs/Web/JavaScript/Reference/Global_Objects/Promise>Promise</a> đã được đưa vào mặc định nhằm giải quyết tình trạng callback hell. Với Promise, mã nguồn của ta sẽ trông gần giống với phong cách đồng bộ, kết quả là trông dễ theo dõi và bảo trì hơn. Tuy nhiên sử dụng <code>Promise</code> lại làm phát sinh vấn đề &ldquo;khá&rdquo; tương tự là Promise hell ( lol! JavaScript Heo! ).</p><figure class="highlight js"><figcaption><span>test2.js</span></figcaption><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br></pre></td><td class=code><pre class="js code-highlight">function wait(ms) {
  return new Promise(r =&gt; setTimeout(r, ms))  
}

function main() {
  console.log(&#39;sắp rồi...&#39;)
  wait(2007).then(() =&gt; {
    console.log(&#39;chờ tí...&#39;)
    return wait(2007)
  }).then(() =&gt; {
    console.log(&#39;thêm chút nữa thôi...&#39;)
    return wait(2012)
  }).then(() =&gt; {
    console.log(&#39;thêm chút nữa thôi...&#39;)
    return wait(2016)
  }).then(() =&gt; {
    console.log(&#39;xong rồi đấy!&#39;)
  })
}</pre></td></tr></tbody></table></figure><p>Để giải quyết vấn đề đó, ở phiên bản ES7 (ES 2017), 1 khái niệm với 2 từ khóa mới được đưa vào là hàm async (<code>async / await</code>). Hàm async cho phép ta viết các thao tác bất đồng bộ với phong cách của các mã đồng bộ. Bằng cách viết như vậy, mã nguồn của ta trông sẽ sáng sủa, dễ đọc hơn và &ldquo;dễ hiểu hơn&rdquo;.</p><figure class="highlight js"><figcaption><span>test3.js</span></figcaption><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre></td><td class=code><pre class="js code-highlight">function wait(ms) {
  return new Promise(r =&gt; setTimeout(r, ms))  
}

async function main() {
  console.log(&#39;sắp rồi...&#39;)
  await wait(2007)
  console.log(&#39;chờ tí...&#39;)
  await wait(2012)
  console.log(&#39;thêm chút nữa thôi...&#39;)
  await wait(2016)
  console.log(&#39;xong rồi đấy!&#39;)
}</pre></td></tr></tbody></table></figure><h1 id=2-cách-sử-dụng>2. Cách sử dụng</h1><p>Để sử dụng hàm async, ta cần khai báo từ khóa <code>async</code> ngay trước từ khóa định nghĩa hàm. Tức là, với hàm định nghĩa với từ khóa <code>function</code> ta phải khai báo ngay trước <code>function</code>, với hàm mũi tên (arrow function) ta phải khai báo trước tập tham số đầu vào, với phương thức của lớp <a href=https://developer.mozilla.org/vi/docs/Web/JavaScript/Reference/Classes><code>Class</code></a> thì ta phải khai báo ngay trước tên hàm.</p><figure class="highlight js"><figcaption><span>test4.js</span></figcaption><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br></pre></td><td class=code><pre class="js code-highlight">// regular function
async function functionName() {
  let ret = await new Google().search(&#39;JavaScript&#39;)
}

// arrow function
let arr = [&#39;JS&#39;, &#39;node.js&#39;].map(async val =&gt; {
  return await new Google().search(val)
})

// Class
class Google {
  constructor() {
    this.apiKey = &#39;...&#39;
  }

  async search(keyword) {
    return await this.searchApi(keyword)
  }
}</pre></td></tr></tbody></table></figure><p>Với từ khóa <code>async</code> này, ta có thể đợi các <code>Promise</code> (thao tác bất đồng bộ) xử lý trong hàm đó mà không tạm dùng luồng chính bằng từ khóa <code>await</code> như ví dụ trên.</p><p>Kết quả trả ra của hàm async luôn là một Promise dù bạn có gọi <code>await</code> - có xử lý bất đồng bộ hay không. Promise này sẽ ở trạng thái thành công với kết quả được trả ra với từ khóa <code>return</code> của hàm async, hoặc trạng thái thất bại với kết quả được đẩy qua từ khóa <code>throw</code> trong hàm async.</p><p>Như vậy, bản chất của hàm async chính là Promise. Nếu bạn chưa tìm hiểu về <code>Promise</code> thì nên đọc trước ở <a href=https://developer.mozilla.org/vi/docs/Web/JavaScript/Reference/Global_Objects/Promise>bài viết này</a>.</p><p>Với Promise, ta có thể xử lý ngoại lệ với <a href=https://developer.mozilla.org/vi/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch><code>catch</code></a> khá đơn giản. Tuy nhiên cũng không dễ dàng theo dõi và dễ đọc. Nhưng với hàm async, việc này cực kì đơn giản bằng từ khóa <code>try catch</code> hệt như các thao tác đồng bộ.</p><figure class="highlight js"><figcaption><span>test5.js</span></figcaption><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br></pre></td><td class=code><pre class="js code-highlight">//
// test.js
//
function wait(ms) {
  return new Promise(r =&gt; setTimeout(r, ms))  
}

async function runner() {
  console.log(&#39;sắp rồi...&#39;)
  await wait(2007)
  console.log(&#39;chờ tí...&#39;)
  await wait(2012)
  console.log(&#39;thêm chút nữa thôi...&#39;)
  await wait(2016)
  throw new Error(2016)
}

async function main() {
  try {
    await runner()
    console.log(&#39;xong rồi đấy!&#39;)
  } catch (e) {
    console.log(`có vấn đề tại ${ e }`)
  }
}

// Node v7
// `$ node --harmony-async-await test.js`
// Console: ... có vấn đề tại 2016</pre></td></tr></tbody></table></figure><p>Ngon! Rõ ràng là mã nguồn sử dụng <code>async/await</code> trông đơn giản, dễ theo dõi, &ldquo;dễ hiểu&rdquo; hơn và giải quyết được tình trạng callback - promise hell. Tuy nhiên, việc sử dụng nó cũng không phải lúc nào cũng đơn giản. Ta cùng nhau xem một số trường hợp dưới đây.</p><h1 id=3-lưu-ý>3. Lưu ý</h1><h2 id=3-1-quên-khai-báo-từ-khóa-async>3.1. Quên khai báo từ khóa <code>async</code></h2><p>Đương nhiên rồi, không khai báo từ khóa này thì ta không có hàm async được, không sử dụng <code>await</code> được rồi. Thường bạn sẽ nghĩ đơn giản là không thể nào quên được từ khóa này, nhưng tôi nghĩ đôi lúc có thể đấy. Ví dụ như với trường hợp khai báo một hàm trong một hàm async. Hàm khai báo trong hàm async cũng bắt buộc phải được khai báo với từ khóa <code>async</code> nếu như bạn muốn sử dụng như một hàm async.</p><figure class="highlight js"><figcaption><span>test6.js</span></figcaption><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre></td><td class=code><pre class="js code-highlight">async function main() {
  await wait(1000)
  let arr = [100, 300, 500].map(val =&gt; wait(val))
  arr.forEach(func =&gt; await func)
  // ??? error
}</pre></td></tr></tbody></table></figure><h2 id=3-2-nhập-nhằng-từ-khóa-await>3.2. Nhập nhằng từ khóa <code>await</code></h2><p>Có 2 tình huống điển hình cho trường hợp này là:</p><ul><li>Quên khai báo khi cần đợi một xử lý bất đồng bộ</li></ul><p>Có gì đáng sợ không? Câu trả lời là có đấy! Nếu bạn không khai báo từ khóa này thì kết quả bạn nhận được sẽ là một <code>Promise</code> chứ không phải là kết quả thực thi của xử lý bất đồng bộ nhé.</p><figure class="highlight js"><figcaption><span>test7.js</span></figcaption><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre></td><td class=code><pre class="js code-highlight">async function now() {
  return Date.now()
}

async function main() {
  let t = now()
  console.log(t)
   // ??? `t` is a `Promise` instance
}</pre></td></tr></tbody></table></figure><ul><li>Khai báo &ldquo;thừa&rdquo; trước một xử lý đồng bộ</li></ul><p>Nếu mà sợ quên thì cứ khai báo bừa đi, đâu có sao? Ừ không sao đâu ngoại trừ 2 vấn đề là không biết cái nào là đồng bộ, cái nào là bất đồng bộ nữa, và hiệu quả đi xuống đấy. Mỗi khi bạn khai báo <code>await</code> thì mặc nhiên sau từ khóa đó là một <code>Promise</code>, nếu không phải là một <code>Promise</code> thì nó sẽ được gói lại vào <code>Promise</code> và được trả ra ngay với phương thức <a href=https://developer.mozilla.org/vi/docs/Web/JavaScript/Reference/Global_Objects/Promise/resolve><code>Promise.resolve(value)</code></a>. Rảnh quá ha, muốn lấy <code>1 + 0 = 1</code> mà phải đi đường vòng là tính tổng, rồi nhét vào Promise, rồi lại moi ra để sử dụng.</p><figure class="highlight js"><figcaption><span>test8.js</span></figcaption><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br></pre></td><td class=code><pre class="js code-highlight">async function main() {
 // run with await
 console.log(&#39;run with await&#39;)
 let i = 1000000
 console.time(&#39;await&#39;)
 while(i-- &gt; 0) {
   let t = await (1 &#43; 0)
 }
 console.timeEnd(&#39;await&#39;)

 // run without await
 console.log(&#39;run without await&#39;)
 i = 1000000
 console.time(&#39;normal&#39;)
 while(i-- &gt; 0) {
   let t = 1 &#43; 0
 }
 console.timeEnd(&#39;normal&#39;)
}</pre></td></tr></tbody></table></figure><h2 id=3-3-quên-xử-lý-lỗi>3.3. Quên xử lý lỗi</h2><p>Cũng như với việc quên <code>catch</code> lỗi khi sử dụng Promise, việc quên <code>try catch</code> để bắt lỗi với hàm async cũng có thể xảy ra. Nếu bạn quên không bắt lỗi, thì khi đoạn mã bất đồng của bạn xảy ra lỗi có thể làm chương trình của bạn bị dừng lại.</p><figure class="highlight js"><figcaption><span>test9.js</span></figcaption><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre></td><td class=code><pre class="js code-highlight">function wait(ms) {
  if (ms &gt; 2015) throw new Error(ms)
  return new Promise(r =&gt; setTimeout(r, ms))
}

async function main() {
  console.log(&#39;sắp rồi...&#39;)
  await wait(2007)
  console.log(&#39;chờ tí...&#39;)
  await wait(2012)
  console.log(&#39;thêm chút nữa thôi...&#39;)
  await wait(2016)
  console.log(&#39;xong rồi đấy!&#39;)
}</pre></td></tr></tbody></table></figure><h2 id=3-4-mất-tính-song-song>3.4. Mất tính song song</h2><p>Cái này có vẻ là căng nhất, bạn cứ khai báo <code>await</code> tuần tự đi rồi chương trình của bạn sẽ chậm như con rùa. hahaaa. Vì mỗi lần khai báo <code>await</code> như vậy là bạn cần phải chờ cho xử lý của await kết thúc. Kết quả là bạn có 1 con rùa chạy tuần tự qua từng nấc thang.</p><figure class="highlight js"><figcaption><span>test10.js</span></figcaption><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre></td><td class=code><pre class="js code-highlight">function wait(ms) {
  return new Promise(r =&gt; setTimeout(r, ms))
}

async function main() {
  console.time(&#39;wait3s&#39;)
  await wait(1000)
  await wait(2000)
  console.timeEnd(&#39;wait3s&#39;)
}</pre></td></tr></tbody></table></figure><p>Với đoạn mã trên bạn sẽ mất tổng cộng là <code>1 + 2 = 3s</code> để thực thi. Vì bạn phải chờ từng hàm <code>wait</code> một. Vậy làm sao để tránh được tình trạng trên? Câu trả lời là cứ cho xử lý bất đồng bộ chạy trước đi rồi lấy kết quả sau. Vì <code>Promise</code> có thể cho phép ta lấy kết quả bất cứ khi nào mà nó ở trạng thái cuối cùng, nên ta có thể chạy nó trước rồi lấy sau cũng không sao cả.</p><figure class="highlight js"><figcaption><span>test11.js</span></figcaption><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre></td><td class=code><pre class="js code-highlight">function wait(ms) {
  return new Promise(r =&gt; setTimeout(r, ms))
}

async function main() {
  console.time(&#39;wait2s&#39;)
  let w1 = wait(1000)
  let w2 = wait(2000)
  await w1
  await w2
  console.timeEnd(&#39;wait2s&#39;)
}</pre></td></tr></tbody></table></figure><p>Như đoạn mã này, ta chỉ mất <code>2s</code> để thực hiện vì đoạn <code>wait</code> của ta được thực thi song song. Ngoài cách <code>await</code> từng <code>Promise</code> như trên ta có thể sử dụng <a href=https://developer.mozilla.org/vi/docs/Web/JavaScript/Reference/Global_Objects/Promise/all><code>Promise.all</code></a> để song song hóa các Promise.</p><figure class="highlight js"><figcaption><span>test12.js</span></figcaption><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre></td><td class=code><pre class="js code-highlight">function wait(ms) {
  return new Promise(r =&gt; setTimeout(r, ms))
}

async function main() {
  console.time(&#39;wait2s&#39;)
  await Promise.all([wait(1000), wait(2000)])
  console.timeEnd(&#39;wait2s&#39;)
}</pre></td></tr></tbody></table></figure><p>Lúc này, có thể bạn đang nghĩ <code>Promise.all</code> và <code>await</code> từng Promise là như nhau, nhưng nó khác nhau chút đấy. <code>Promise.all</code> chỉ ở trạng thái thành công khi mà tất cả các Promise được truyền vào xử lý thành công, còn nó sẽ ở trạng thái lỗi khi một trong các Promise truyền vào bị lỗi. Như vậy, nếu bạn muốn bỏ qua các Promise lỗi thì bạn không thể sử dụng <code>Promise.all</code> được đâu. Lúc đó bắt buộc bạn phải sử dụng <code>await</code> kèm với <code>try catch</code> cho từng Promise của bạn.</p><figure class="highlight js"><figcaption><span>test12.js</span></figcaption><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br></pre></td><td class=code><pre class="js code-highlight">function wait(ms) {
  if (ms &gt; 2000) throw new Error(ms)
  return new Promise(r =&gt; setTimeout(r, ms))
}

async function main() {
  const dur = [1000, 2000, 3000, 4000]
  let all = dur.map(ms =&gt; wait(ms))
  try {
    await Promise.all(all)
    console.log(&#39;Promise.all - done&#39;)
  } catch (e) {
    console.error(&#39;Promise.all:&#39;, e)  
  }

  let each = dur.map(ms =&gt; wait(ms))
  each.forEach(async (func, index) =&gt; {
    try {
      await func
      console.log(&#39;each - done:&#39;, dur[index])
    } catch (e) {
      console.error(&#39;each:&#39;, e)  
    }
  })
}</pre></td></tr></tbody></table></figure><h1 id=4-nền-tảng-trình-duyệt-hỗ-trợ>4. Nền tảng/ trình duyệt hỗ trợ</h1><p>Thời điểm này (<sup>2016</sup>&frasl;<sub>10</sub>), các nền tảng và trình duyệt sau đã hỗ trợ hàm async.</p><ul><li>Node.js v7.0 với cờ <code>--harmony-async-await</code></li><li>Chrome v5.55</li><li>Microsoft Edge v21.10547</li></ul><p>Nếu bạn muốn chạy ở các nền tảng/ trình duyệt chưa hỗ trợ thì có thể dùng babel để chuyển đổi:</p><ul><li>Babel <a href=https://babeljs.io/docs/plugins/transform-async-to-generator/>async-2-generator plugin</a></li></ul><h1 id=5-kết-luận>5. Kết luận</h1><p>Bản chất của hàm async chính là <code>Promise</code>, vì vậy để sử dụng được nó ta cần phải sử dụng <code>Promise</code> cho việc xử lý các thao tác bất đồng bộ. Bạn không thể nào sài <code>await</code> để đợi các hàm có sử dụng hàm phản hồi (callback) được, mà bắt buộc phải gắn nó với một Promise trước khi sử dụng <code>await</code>.</p><p>Mặc dù hàm async có cú pháp rất rõ ràng, ta cũng cần phải lưu ý tránh khai báo thừa thiếu các từ khóa gây lỗi, gây hiểu lầm về lô-gíc chương trình. Và đặc biệt lưu ý tới khả năng làm mất đi tính song song của chương trình.</p><p>Với sự tiện dụng của hàm async, ta nên cố gắng sử dụng nó ngay từ bây giờ để giảm thiểu việc bảo trì sau này. Với các nền tảng/ trình duyệt chưa hỗ trợ thì ta có thể chuyển đổi bằng <a href=https://babeljs.io/>babel</a>. Hiện tại Node v7 vẫn đang sử dụng Chrome v5.54 nên muốn sử dụng được async/await, ta buộc phải chạy với cờ <code>--harmony-async-await</code> và hiệu năng, bộ nhớ được sử dụng vẫn chưa hiệu quả, không khuyến khích cho các sản phẩm thực tế. Tuy nhiên, rất có thể Node v8 sẽ sử dụng phiên bản Chrome v5.55 và cho phép ta thực hiện mặc định các hàm async.</p><p><code>async</code> chúc các bạn <code>await</code> vui vẻ!</p></div></div><div id=post-footer class="post-footer main-content-wrap"><div class=post-footer-tags><span class="text-color-light text-small">THẺ ĐÁNH DẤU</span><br><a class="tag tag--primary tag--small" href=https://dominhhai.github.io/vi/tags/js/>JS</a>
<a class="tag tag--primary tag--small" href=https://dominhhai.github.io/vi/tags/js-tips/>JS Tips</a>
<a class="tag tag--primary tag--small" href=https://dominhhai.github.io/vi/tags/es2017/>ES2017</a></div><div class=post-actions-wrap><nav><ul class="post-actions post-action-nav"><li class=post-action><a class="post-action-btn btn btn--default tooltip--top" href=https://dominhhai.github.io/vi/2016/11/nodefest-tokyo-2016/ data-tooltip="[NodeFest] NodeFest Tokyo 2016"><i class="fa fa-angle-left"></i><span class="hide-xs hide-sm text-small icon-ml">Tiếp</span></a></li><li class=post-action><a class="post-action-btn btn btn--default tooltip--top" href=https://dominhhai.github.io/vi/2016/06/alias-for-command-on-macos/ data-tooltip="[Terminal] Tạo Alias cho lệnh trên MacOS"><span class="hide-xs hide-sm text-small icon-mr">Trước</span>
<i class="fa fa-angle-right"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href=#btn-open-shareoptions><i class="fa fa-share-alt"></i></a></li><li class="post-action hide-xs"><a class="post-action-btn btn btn--default" target=new href="https://www.facebook.com/sharer/sharer.php?u=https://dominhhai.github.io/vi/2016/10/js-async-await-is-simple/"><i class="fa fa-facebook-official"></i></a></li><li class="post-action hide-xs"><a class="post-action-btn btn btn--default" target=new href="https://twitter.com/intent/tweet?text=https://dominhhai.github.io/vi/2016/10/js-async-await-is-simple/"><i class="fa fa-twitter"></i></a></li><li class="post-action hide-xs"><a class="post-action-btn btn btn--default" target=new href="https://plus.google.com/share?url=https://dominhhai.github.io/vi/2016/10/js-async-await-is-simple/"><i class="fa fa-google-plus"></i></a></li><li class=post-action><a class="post-action-btn btn btn--default" href=#disqus_thread><i class="fa fa-comment-o"></i></a></li><li class=post-action><a class="post-action-btn btn btn--default" href=#table-of-contents><i class="fa fa-list"></i></a></li></ul></div><div id=disqus_thread><noscript>Please enable JavaScript to view the <a href=//disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></div></div></article><footer id=footer class=main-content-wrap><div id=helpinfo><div id=author><label id=home>Hai's Blog</label><div class=language><label for=language>Other Languages:</label>
<select id=language>
<option title="Tiếng Việt" value=vi selected>Tiếng Việt (vi)</option>
<option title=English value=en-us>English (en-us)</option>
<option title=日本語 value=ja>日本語 (ja)</option></select></div></div><div id=topic><label>Chủ đề</label><ul><li><a href=https://dominhhai.github.io/vi/categories/l%E1%BA%ADp-tr%C3%ACnh/>Lập Trình</a></li><li><a href=https://dominhhai.github.io/vi/categories/h%E1%BB%8Dc-m%C3%A1y/>Học Máy</a></li><li><a href=https://dominhhai.github.io/vi/categories/to%C3%A1n/>Toán</a></li><li><a href=https://dominhhai.github.io/vi/categories/x%C3%A1c-su%E1%BA%A5t/>Xác Suất</a></li><li><a href=https://dominhhai.github.io/vi/categories/s%C3%A1ch/>Sách</a></li></ul></div><div id=contact><label>Liên hệ</label><ul><li><a href=https://github.com/dominhhai/dominhhai.github.io/issues/new target=_blank><i class="fa fa-lg fa-inbox"></i>Gửi tin nhắn</a></li><li id=follow><a href=https://github.com/dominhhai target=_blank><i class="sidebar-button-icon fa fa-lg fa-github"></i></a><a href=https://twitter.com/minhhai3b target=_blank><i class="sidebar-button-icon fa fa-lg fa-twitter"></i></a></li></ul></div></div><div id=contentinfo><span class=copyrights>&copy; 2017 <a href=https://github.com/dominhhai>Do Minh Hai</a>. All Rights Reserved</span></div></footer></div><div id=bottom-bar class=post-bottom-bar data-behavior=5><div class=post-actions-wrap><nav><ul class="post-actions post-action-nav"><li class=post-action><a class="post-action-btn btn btn--default tooltip--top" href=https://dominhhai.github.io/vi/2016/11/nodefest-tokyo-2016/ data-tooltip="[NodeFest] NodeFest Tokyo 2016"><i class="fa fa-angle-left"></i><span class="hide-xs hide-sm text-small icon-ml">Tiếp</span></a></li><li class=post-action><a class="post-action-btn btn btn--default tooltip--top" href=https://dominhhai.github.io/vi/2016/06/alias-for-command-on-macos/ data-tooltip="[Terminal] Tạo Alias cho lệnh trên MacOS"><span class="hide-xs hide-sm text-small icon-mr">Trước</span>
<i class="fa fa-angle-right"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href=#btn-open-shareoptions><i class="fa fa-share-alt"></i></a></li><li class="post-action hide-xs"><a class="post-action-btn btn btn--default" target=new href="https://www.facebook.com/sharer/sharer.php?u=https://dominhhai.github.io/vi/2016/10/js-async-await-is-simple/"><i class="fa fa-facebook-official"></i></a></li><li class="post-action hide-xs"><a class="post-action-btn btn btn--default" target=new href="https://twitter.com/intent/tweet?text=https://dominhhai.github.io/vi/2016/10/js-async-await-is-simple/"><i class="fa fa-twitter"></i></a></li><li class="post-action hide-xs"><a class="post-action-btn btn btn--default" target=new href="https://plus.google.com/share?url=https://dominhhai.github.io/vi/2016/10/js-async-await-is-simple/"><i class="fa fa-google-plus"></i></a></li><li class=post-action><a class="post-action-btn btn btn--default" href=#disqus_thread><i class="fa fa-comment-o"></i></a></li><li class=post-action><a class="post-action-btn btn btn--default" href=#table-of-contents><i class="fa fa-list"></i></a></li></ul></div></div><div id=share-options-bar class=share-options-bar data-behavior=5><i id=btn-close-shareoptions class="fa fa-close"></i><ul class=share-options><li class=share-option><a class=share-option-btn target=new href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fdominhhai.github.io%2Fvi%2F2016%2F10%2Fjs-async-await-is-simple%2F"><i class="fa fa-facebook-official"></i><span>Chia sẻ với Facebook</span></a></li><li class=share-option><a class=share-option-btn target=new href="https://twitter.com/intent/tweet?text=https%3A%2F%2Fdominhhai.github.io%2Fvi%2F2016%2F10%2Fjs-async-await-is-simple%2F"><i class="fa fa-twitter"></i><span>Chia sẻ với Twitter</span></a></li><li class=share-option><a class=share-option-btn target=new href="https://plus.google.com/share?url=https%3A%2F%2Fdominhhai.github.io%2Fvi%2F2016%2F10%2Fjs-async-await-is-simple%2F"><i class="fa fa-google-plus"></i><span>Chia sẻ với Google&#43;</span></a></li></ul></div><div id=share-options-mask class=share-options-mask></div></div><div id=about><div id=about-card><div id=about-btn-close><i class="fa fa-remove"></i></div><img id=about-card-picture src="https://www.gravatar.com/avatar/711b36be8e444cd1d60b348077bfd752?s=110" alt="Ảnh đại diện"><h4 id=about-card-name>Do Minh Hai</h4><div id=about-card-bio>Just a developer<br>Enjoy life as a journey</div><div id=about-card-job><i class="fa fa-briefcase"></i><br>Freelancer</div><div id=about-card-location><i class="fa fa-map-marker"></i><br>Japan</div></div></div><div id=algolia-search-modal class=modal-container><div class=modal><div class=modal-header><span class=close-button><i class="fa fa-close"></i></span><a href=https://algolia.com target=_blank rel=noopener class="searchby-algolia text-color-light link-unstyled"><span class="searchby-algolia-text text-color-light text-small">by</span>
<img class=searchby-algolia-logo src=https://www.algolia.com/static_assets/images/press/downloads/algolia-light.svg></a>
<i class="search-icon fa fa-search"></i><form id=algolia-search-form><input id=algolia-search-input name=search class="form-control input--large search-input" placeholder="Tìm kiếm"></form></div><div class=modal-body><div class="no-result text-color-light text-center">không tìm thấy kết quả</div><div class=results><div class=media><div class=media-body><a class=link-unstyled href=https://dominhhai.github.io/vi/2017/12/ml-linear-regression-mle/><h3 class=media-heading>[ML] MLE của hồi quy tuyến tính</h3></a><span class=media-meta><span class="media-date text-small">Dec 12, 2017</span></span><div class="media-content hide-xs font-merryweather"><p>Như bài viết trước đã đề cập tới phương pháp ước lượng tham số bằng công thức chuẩn cho thuật toán hồi quy tuyến tính $\hat\theta=(\Phi^{\intercal}\Phi)^{-1}\Phi^{\intercal}\mathbf{y}$ bằng cách lấy đạo hàm hàm lỗi (<em>mean squared error</em>). Có thể bạn sẽ nghi ngờ về mức độ tin cậy thống kê của phương pháp ước lượng đó, nên bài viết này sẽ phân tích lý thuyết xác suất ước lượng bằng <a href=https://dominhhai.github.io/vi/2017/10/sampling-parameters-estimation/#2-2-mle>MLE (<em>Maximum Likelihood Esitmation</em>)</a> xem sao.</p></div></div><div style=clear:both></div><hr></div><div class=media><div class=media-body><a class=link-unstyled href=https://dominhhai.github.io/vi/2017/12/ml-linear-regression/><h3 class=media-heading>[ML] Hồi quy tuyến tính (Linear Regression)</h3></a><span class=media-meta><span class="media-date text-small">Dec 12, 2017</span></span><div class="media-content hide-xs font-merryweather"><p>Học có giám sát (<em>Supervised Learning</em>) được chia ra làm 2 dạng lớn là <strong>hồi quy</strong> (<em>regression</em>) và <strong>phân loại</strong> (<em>classification</em>) dựa trên tập dữ liệu mẫu - tập huấn luyện (<em>training data</em>). Với bài đầu tiên này ta sẽ bắt đầu bằng bài toán hồi quy mà cụ thể là hồi quy tuyến tính (<em>linear regression</em>).</p></div></div><div style=clear:both></div><hr></div><div class=media><div class=media-body><a class=link-unstyled href=https://dominhhai.github.io/vi/2017/12/ml-prml/><h3 class=media-heading>Pattern Recognition and Machine Learning</h3></a><span class=media-meta><span class="media-date text-small">Dec 12, 2017</span></span><div class="media-content hide-xs font-merryweather"><p>Được coi là sách giáo khoa cho những người làm học máy, cuốn sách này viết về các giải thuật và lý thuyết xây dựng các giải thuật nhận dạng mẫu và học máy. Tuy nhiên lúc mới đọc thì thấy khá khó nhằn nên tôi đã tìm hiểu độ khó các phần đề biết đường mà đọc.</p></div></div><div style=clear:both></div><hr></div><div class=media><div class=media-body><a class=link-unstyled href=https://dominhhai.github.io/vi/2017/12/ml-intro/><h3 class=media-heading>[ML] Học máy là gì?</h3></a><span class=media-meta><span class="media-date text-small">Dec 12, 2017</span></span><div class="media-content hide-xs font-merryweather"><p>Thời gian gần đây AI nổi lên mạnh mẽ xâm nhập vào rất nhiều lĩnh vực trong cuộc sống như tự động dịch thuật, nhận dạng giọng nói, điều khiển tự động, v.v. Nó giờ được coi là xu hướng công nghệ thế giới và nhiều người cho rằng đó là cuộc cách mạng công nghiệp lần thứ 4.</p></div></div><div style=clear:both></div><hr></div><div class=media><div class=media-body><a class=link-unstyled href=https://dominhhai.github.io/vi/2017/11/seiko-no-yotei/><h3 class=media-heading>Điểm cốt lõi để thành công</h3></a><span class=media-meta><span class="media-date text-small">Nov 11, 2017</span></span><div class="media-content hide-xs font-merryweather">Cuốn sách tổng hợp nội dung của một số buổi nói chuyện của ông Inamori Kazuo về kinh doanh, làm việc, nhân sinh. Vẫn phong cách quen thuộc về cách nhìn cuộc sống, cách suy nghĩ, cách hành động như trong các cuốn sách khác mà ông đã viết, nhưng trong cuốn này đặc biệt ở chỗ tổng hợp được nhiều nội dung khá cô động mà vẫn không thiếu sót nội dung.</div></div><div style=clear:both></div><hr></div><div class=media><div class=media-body><a class=link-unstyled href=https://dominhhai.github.io/vi/2017/11/vbnet-oracle-version/><h3 class=media-heading>[.NET] Sài nhiều phiên bản Oracle khi thực thi</h3></a><span class=media-meta><span class="media-date text-small">Nov 11, 2017</span></span><div class="media-content hide-xs font-merryweather"><p>Thông thường khi ta build ứng dụng thì phiên bản Oracle DB ở môi trường phát triển và môi trường thực thi là giống nhau nên không xảy ra vấn đề gì cả. Nhưng nếu ở môi trường phát triển và thực thi khác nhau thì sao?</p></div></div><div style=clear:both></div><hr></div><div class=media><div class=media-body><a class=link-unstyled href=https://dominhhai.github.io/vi/2017/11/what-is-http2/><h3 class=media-heading>[Web] HTTP2 là gì?</h3></a><span class=media-meta><span class="media-date text-small">Nov 11, 2017</span></span><div class="media-content hide-xs font-merryweather"><p>Nhân tiện bản <code>Node v9x</code> mới ra cho phép ta có thể sử dụng ngay API thử nghiệm <code>HTTP/2</code> nên cũng tò mò tìm hiểu đôi chút xem kiến trúc, đặc điểm và cách sử dụng thế nào.
Sau 2 năm ra chính thức ra lò, phiên bản tiếp theo của <code>HTTP</code> này dần được nhiều máy chủ Web lẫn trình duyệt hỗ trợ bởi tính vượt trội của nó so với phiên bản <code>HTTP/1.1</code>.</p></div></div><div style=clear:both></div><hr></div><div class=media><div class=media-body><a class=link-unstyled href=https://dominhhai.github.io/vi/2017/11/about-git/><h3 class=media-heading>[Git] Mô tả về GIT của Linus Torvalds</h3></a><span class=media-meta><span class="media-date text-small">Nov 11, 2017</span></span><div class="media-content hide-xs font-merryweather"><p>Đây là mô tả về GIT mà chủ nhân của nó - ông Linus Torvalds đã viết khi công khai mã nguồn. Cụ thể bài này được copy lại từ <a href=https://github.com/git/git/tree/e83c5163316f89bfbde7d9ab23ca2e25604af290 target=_blank _ rel="noopener noreferrer">Github</a>.</p></div></div><div style=clear:both></div><hr></div><div class=media><div class=media-body><a class=link-unstyled href=https://dominhhai.github.io/vi/2017/10/change-filename-bat/><h3 class=media-heading>[Windows] Đổi tên file với .bat file</h3></a><span class=media-meta><span class="media-date text-small">Oct 10, 2017</span></span><div class="media-content hide-xs font-merryweather">Gần đây Gmail không cho phép gửi các file có đuôi là mã nguồn ngôn ngữ lập trình như .js, .vb chẳng hạn. Ngay cả việc đổi đuôi của các file nén cũng không có hiệu quả như trước, nên buộc phải tìm cách đổi toàn bộ đuôi 1 phát.
Bài viết này sẽ nói về cách thay đổi toàn bộ đuôi file bằng .bat file của Windows, tuy nhiên hoàn toàn có thể sử dụng để làm những chuyện khác với các file này như đổi tên chẳng hạn.</div></div><div style=clear:both></div><hr></div><div class=media><div class=media-body><a class=link-unstyled href=https://dominhhai.github.io/vi/2017/10/implement-gru-lstm/><h3 class=media-heading>[RNN] Cài đặt GRU/LSTM</h3></a><span class=media-meta><span class="media-date text-small">Oct 10, 2017</span></span><div class="media-content hide-xs font-merryweather"><blockquote><p>Bài giới thiệu RNN cuối cùng này được dịch lại từ trang <a href=http://www.wildml.com/2015/10/recurrent-neural-network-tutorial-part-4-implementing-a-grulstm-rnn-with-python-and-theano/ target=_blank _ rel="noopener noreferrer">blog WILDML</a>.</p></blockquote><p>Trong phần này ta sẽ tìm hiểu về LSTM (Long Short-Term Memory) và GRU (Gated Recurrent Units).
LSTM lần đầu được giới thiệu vào năm 1997 bởi <a href=https://github.com/dzitkowskik/StockPredictionRNN/blob/master/docs/Hochreiter97_lstm.pdf target=_blank _ rel="noopener noreferrer">Sepp Hochreiter và Jürgen Schmidhuber</a>.
Nó giờ hiện diện trên hầu hết các mô hình có sử dụng học sâu cho NPL.
Còn GRU mới được đề xuất vào năm 2014 là một phiên bản đơn giản hơn của LSTM nhưng vẫn giữ được các tính chất của LSTM.</p></div></div><div style=clear:both></div><hr></div></div></div><div class=modal-footer><p class="results-count text-medium" data-message-zero="không tìm thấy kết quả" data-message-one="tìm thấy 1 kết quả" data-message-other="tìm thấy {n} kết quả">54 posts found</p></div></div></div><div id=cover style=background-image:url(https://dominhhai.github.io/images/cover-v1.2.0.jpg)></div><script src=https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js integrity="sha256-IFHWFEbU2/+wNycDECKgjIRSirRNIDp2acEB5fvdVRU=" crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.8.0/highlight.min.js integrity="sha256-+mpyNVJsNt4rVXCw0F+pAOiB3YxmHgrbJsx4ecPuUaI=" crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/jquery.fancybox.min.js integrity="sha256-vMxgR/7FtLovVA+IPrR7+xTgIgARH7y9VZQnmmi0HDI=" crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/helpers/jquery.fancybox-thumbs.min.js integrity="sha256-N0qFUh7/9vLvia87dDndewmsgsyYoNkdA212tPc+2NI=" crossorigin=anonymous></script><script src=https://dominhhai.github.io/js/script-qi9wbxp2ya2j6p7wx1i6tgavftewndznf4v0hy2gvivk1rxgc3lm7njqb6bz.min.js></script><script crossorigin=anonymous integrity=sha384-GR8SEkOO1rBN/jnOcQDFcFmwXAevSLx7/Io9Ps1rkxWp983ZIuUGfxivlF/5f5eJ src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0-alpha1/katex.min.js></script><script crossorigin=anonymous integrity=sha384-cXpztMJlr2xFXyDSIfRWYSMVCXZ9HeGXvzyKTYrn03rsMAlOtIQVzjty5ULbaP8L src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0-alpha1/contrib/auto-render.min.js></script><script src=https://dominhhai.github.io/js/main.js></script><script>$(document).ready(function(){hljs.configure({classPrefix:'',useBR:false});$('pre.code-highlight, pre > code').each(function(i,block){if(!$(this).hasClass('codeblock')){$(this).addClass('codeblock');}
hljs.highlightBlock(block);});});</script><script>var disqus_config=function(){this.page.url='https:\/\/dominhhai.github.io\/vi\/2016\/10\/js-async-await-is-simple\/';this.page.identifier='\/vi\/2016\/10\/js-async-await-is-simple\/'};(function(){if(window.location.hostname=="localhost"){return;}
var d=document,s=d.createElement('script');var disqus_shortname='tranquilpeak';s.src='//'+disqus_shortname+'.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><script>if(typeof fnMain==='function'){fnMain();}</script></body></html>